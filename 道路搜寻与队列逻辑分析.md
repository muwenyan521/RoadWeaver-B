# RoadWeaver é“è·¯æœå¯»ä¸é˜Ÿåˆ—é€»è¾‘è¯¦ç»†åˆ†æ

## ğŸ“‹ ç›®å½•
1. [ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ](#ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ)
2. [æ ¸å¿ƒæ•°æ®ç»“æ„](#æ ¸å¿ƒæ•°æ®ç»“æ„)
3. [ç»“æ„æœå¯»æµç¨‹](#ç»“æ„æœå¯»æµç¨‹)
4. [é˜Ÿåˆ—ç®¡ç†æœºåˆ¶](#é˜Ÿåˆ—ç®¡ç†æœºåˆ¶)
5. [é“è·¯ç”Ÿæˆæµç¨‹](#é“è·¯ç”Ÿæˆæµç¨‹)
6. [å¹¶å‘æ§åˆ¶](#å¹¶å‘æ§åˆ¶)
7. [çŠ¶æ€ç®¡ç†](#çŠ¶æ€ç®¡ç†)
8. [å…³é”®æ—¶åºå›¾](#å…³é”®æ—¶åºå›¾)

---

## ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

### æ ¸å¿ƒç»„ä»¶å…³ç³»
```
ModEventHandler (äº‹ä»¶é©±åŠ¨)
    â†“
StructureConnector (è¿æ¥ç®¡ç†)
    â†“
StructureLocator â†’ StructureLocatorImpl (ç»“æ„æœå¯»)
    â†“
WorldDataProvider (æ•°æ®æŒä¹…åŒ–)
    â†“
Road â†’ RoadPathCalculator (é“è·¯ç”Ÿæˆ)
```

---

## æ ¸å¿ƒæ•°æ®ç»“æ„

### 1. **StructureConnection** (ç»“æ„è¿æ¥)
```java
public record StructureConnection(
    BlockPos from,              // èµ·ç‚¹
    BlockPos to,                // ç»ˆç‚¹
    ConnectionStatus status,    // çŠ¶æ€
    boolean manual              // æ˜¯å¦æ‰‹åŠ¨åˆ›å»º
)
```

**çŠ¶æ€æšä¸¾ (ConnectionStatus):**
- `PLANNED` - å·²è§„åˆ’ï¼Œç­‰å¾…ç”Ÿæˆ
- `GENERATING` - ç”Ÿæˆä¸­
- `COMPLETED` - å·²å®Œæˆ
- `FAILED` - ç”Ÿæˆå¤±è´¥

### 2. **å…¨å±€é˜Ÿåˆ—**
```java
// StructureConnector.java:15
public static Queue<Records.StructureConnection> cachedStructureConnections = new ArrayDeque<>();
```
- **ç±»å‹**: `ArrayDeque` (åŒç«¯é˜Ÿåˆ—)
- **ä½œç”¨**: ç¼“å­˜å¾…ç”Ÿæˆçš„é“è·¯è¿æ¥
- **çº¿ç¨‹å®‰å…¨**: âŒ éçº¿ç¨‹å®‰å…¨ï¼Œä¾èµ–å•çº¿ç¨‹ tick è®¿é—®

### 3. **ä»»åŠ¡è¿½è¸ª**
```java
// ModEventHandler.java:38
private static final ConcurrentHashMap<String, Future<?>> runningTasks = new ConcurrentHashMap<>();
```
- **é”®**: `worldKey_timestamp` (ä¸–ç•Œç»´åº¦ + çº³ç§’æ—¶é—´æˆ³)
- **å€¼**: å¼‚æ­¥ä»»åŠ¡çš„ `Future` å¯¹è±¡

---

## ç»“æ„æœå¯»æµç¨‹

### é˜¶æ®µ 1: è§¦å‘æœå¯»

#### 1.1 ä¸–ç•ŒåŠ è½½æ—¶åˆå§‹åŒ–
```java
// ModEventHandler.java:82-108
private static void onWorldLoad(ServerLevel level) {
    // 1. è®¾ç½®åˆå§‹åŒ–å»¶è¿Ÿ (100 ticks = 5ç§’)
    worldInitDelay.put(worldKey, INIT_DELAY_TICKS);
    
    // 2. æ¢å¤æœªå®Œæˆä»»åŠ¡
    restoreUnfinishedRoads(level);
    
    // 3. åˆå§‹ç»“æ„æœå¯»
    if (structureCount < config.initialLocatingCount()) {
        for (int i = 0; i < config.initialLocatingCount(); i++) {
            StructureConnector.cacheNewConnection(level, false);
        }
    }
}
```

**å…³é”®å‚æ•°:**
- `INIT_DELAY_TICKS = 100` - å»¶è¿Ÿ 5 ç§’ç¡®ä¿æ³¨å†Œè¡¨åŠ è½½å®Œæˆ
- `initialLocatingCount` - åˆå§‹æœå¯»çš„ç»“æ„æ•°é‡ (é…ç½®é¡¹)

#### 1.2 Tick äº‹ä»¶è§¦å‘
```java
// ModEventHandler.java:64-70
TickEvent.SERVER_PRE.register(server -> {
    for (ServerLevel level : server.getAllLevels()) {
        if (level.dimension().equals(Level.OVERWORLD)) {
            tryGenerateNewRoads(level, true, 5000);
        }
    }
});
```

### é˜¶æ®µ 2: æ‰§è¡Œæœå¯»

#### 2.1 ç¼“å­˜æ–°è¿æ¥
```java
// StructureConnector.java:17-41
public static void cacheNewConnection(ServerLevel serverWorld, boolean locateAtPlayer) {
    // 1. è®°å½•å½“å‰ç»“æ„æ•°é‡
    int beforeCount = dataProvider.getStructureLocations(serverWorld).structureLocations().size();
    
    // 2. è°ƒç”¨å¹³å°ç‰¹å®šçš„ç»“æ„å®šä½
    StructureLocator.locateConfiguredStructure(serverWorld, 1, locateAtPlayer);
    
    // 3. æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°æ–°ç»“æ„
    int afterCount = locations.size();
    
    // 4. è‡³å°‘éœ€è¦ 2 ä¸ªç»“æ„æ‰èƒ½åˆ›å»ºè¿æ¥
    if (locations.size() < 2) return;
    
    // 5. åˆ›å»ºæ–°è¿æ¥
    createNewStructureConnection(serverWorld);
}
```

#### 2.2 ç»“æ„å®šä½å®ç°
```java
// StructureLocatorImpl.java:37-86
public static void locateConfiguredStructure(ServerLevel level, int locateCount, boolean locateAtPlayer) {
    // 1. è§£æç›®æ ‡ç»“æ„ (æ”¯æŒæ ‡ç­¾å’Œå•ä¸ªç»“æ„)
    Optional<HolderSet<Structure>> targetStructures = resolveStructureTargets(level, config.structuresToLocate());
    
    // 2. æ”¶é›†æœç´¢ä¸­å¿ƒç‚¹
    List<BlockPos> centers = collectSearchCenters(level, locateAtPlayer);
    
    // 3. éå†ä¸­å¿ƒç‚¹æœå¯»ç»“æ„
    for (BlockPos center : centers) {
        Pair<BlockPos, Holder<Structure>> result = level.getChunkSource()
            .getGenerator()
            .findNearestMapStructure(level, targetStructures.get(), center, radius, true);
        
        // 4. å»é‡å¹¶æ·»åŠ åˆ°å·²çŸ¥ä½ç½®
        if (result != null && !containsBlockPos(knownLocations, structurePos)) {
            knownLocations.add(structurePos);
            newlyFound.add(structurePos);
        }
    }
}
```

**æœç´¢ä¸­å¿ƒç‚¹ç­–ç•¥:**
```java
// StructureLocatorImpl.java:225-252
private static List<BlockPos> collectSearchCenters(ServerLevel level, boolean locateAtPlayer) {
    if (locateAtPlayer) {
        // ä½¿ç”¨æ‰€æœ‰ç©å®¶ä½ç½®
        for (ServerPlayer player : level.players()) {
            centers.add(player.blockPosition());
        }
    } else {
        // ä½¿ç”¨å‡ºç”Ÿç‚¹ + æ‰©å±•é‡‡æ ·ç‚¹
        BlockPos spawn = level.getSharedSpawnPos();
        centers.add(spawn);
        
        // åœ¨ 8 ä¸ªæ–¹å‘ä¸ŠæŒ‰åŠå¾„å€æ•° (3x, 6x) é‡‡æ ·
        int[] muls = {3, 6};
        for (int m : muls) {
            int d = radius * m;
            // æ·»åŠ  8 ä¸ªæ–¹å‘çš„é‡‡æ ·ç‚¹
            centers.add(spawn.offset(Â±d, 0, Â±d));
        }
    }
}
```

### é˜¶æ®µ 3: åˆ›å»ºè¿æ¥

#### 3.1 å¯»æ‰¾æœ€è¿‘ç»“æ„
```java
// StructureConnector.java:43-71
private static void createNewStructureConnection(ServerLevel serverWorld) {
    // 1. è·å–æœ€æ–°æ·»åŠ çš„ç»“æ„ (åˆ—è¡¨æœ«å°¾)
    BlockPos latestVillagePos = worldStructureLocations.get(worldStructureLocations.size() - 1);
    
    // 2. å¯»æ‰¾æœ€è¿‘çš„å…¶ä»–ç»“æ„
    BlockPos closestVillage = findClosestStructure(latestVillagePos, worldStructureLocations);
    
    // 3. æ£€æŸ¥è¿æ¥æ˜¯å¦å·²å­˜åœ¨ (åŒå‘æ£€æŸ¥)
    if (!connectionExists(connections, latestVillagePos, closestVillage)) {
        // 4. åˆ›å»ºæ–°è¿æ¥ (é»˜è®¤çŠ¶æ€: PLANNED)
        Records.StructureConnection structureConnection = new Records.StructureConnection(latestVillagePos, closestVillage);
        
        // 5. æŒä¹…åŒ–åˆ°æ•°æ®æä¾›è€…
        connections.add(structureConnection);
        dataProvider.setStructureConnections(serverWorld, connections);
        
        // 6. åŠ å…¥é˜Ÿåˆ—
        cachedStructureConnections.add(structureConnection);
    }
}
```

#### 3.2 æœ€è¿‘ç»“æ„ç®—æ³•
```java
// StructureConnector.java:83-96
private static BlockPos findClosestStructure(BlockPos currentVillage, List<BlockPos> allVillages) {
    BlockPos closestVillage = null;
    double minDistance = Double.MAX_VALUE;
    
    for (BlockPos village : allVillages) {
        if (!village.equals(currentVillage)) {
            double distance = currentVillage.distSqr(village);  // å¹³æ–¹è·ç¦»
            if (distance < minDistance) {
                minDistance = distance;
                closestVillage = village;
            }
        }
    }
    return closestVillage;
}
```

---

## é˜Ÿåˆ—ç®¡ç†æœºåˆ¶

### 1. é˜Ÿåˆ—æ“ä½œæµç¨‹

#### 1.1 å…¥é˜Ÿ (Enqueue)
```java
// StructureConnector.java:61
cachedStructureConnections.add(structureConnection);
```

**å…¥é˜Ÿæ—¶æœº:**
- âœ… ä¸–ç•ŒåŠ è½½æ—¶æ¢å¤ `PLANNED` å’Œ `GENERATING` çŠ¶æ€çš„è¿æ¥
- âœ… æ–°ç»“æ„æœå¯»æˆåŠŸååˆ›å»ºè¿æ¥
- âœ… `GENERATING` çŠ¶æ€é‡ç½®ä¸º `PLANNED` åé‡æ–°å…¥é˜Ÿ

#### 1.2 å‡ºé˜Ÿ (Dequeue)
```java
// ModEventHandler.java:150-167
if (!StructureConnector.cachedStructureConnections.isEmpty()) {
    // 1. å…ˆçª¥è§†é˜Ÿåˆ—å¤´éƒ¨ (peek)
    Records.StructureConnection structureConnection = StructureConnector.cachedStructureConnections.peek();
    
    // 2. æ£€æŸ¥èµ„æºæ˜¯å¦å°±ç»ª (æ³¨å†Œè¡¨ã€é…ç½®ç­‰)
    final RoadFeatureConfig roadConfig = getRoadFeatureConfig(level);
    if (roadConfig == null) {
        return;  // ç­‰å¾…ä¸‹ä¸€ä¸ª tick
    }
    
    // 3. ç¡®è®¤èµ„æºå¯ç”¨åå†çœŸæ­£å‡ºé˜Ÿ (poll)
    StructureConnector.cachedStructureConnections.poll();
    
    // 4. æäº¤ç”Ÿæˆä»»åŠ¡
    submitRoadGenerationTask(structureConnection);
}
```

**å…³é”®è®¾è®¡:**
- ğŸ” **å…ˆ peek å poll** - é¿å…èµ„æºæœªå°±ç»ªæ—¶ä¸¢å¤±ä»»åŠ¡
- â³ **å»¶è¿Ÿå‡ºé˜Ÿ** - ç¡®ä¿æ³¨å†Œè¡¨å®Œå…¨åŠ è½½

### 2. é˜Ÿåˆ—æ¢å¤æœºåˆ¶

#### 2.1 ä¸–ç•ŒåŠ è½½æ—¶æ¢å¤
```java
// ModEventHandler.java:295-339
private static void restoreUnfinishedRoads(ServerLevel level) {
    List<Records.StructureConnection> connections = dataProvider.getStructureConnections(level);
    
    for (int i = 0; i < updatedConnections.size(); i++) {
        Records.StructureConnection connection = updatedConnections.get(i);
        
        // æ¢å¤ PLANNED å’Œ GENERATING çŠ¶æ€
        if (connection.status() == Records.ConnectionStatus.PLANNED ||
            connection.status() == Records.ConnectionStatus.GENERATING) {
            
            // GENERATING â†’ PLANNED (æ„å¤–ä¸­æ–­çš„ä»»åŠ¡)
            if (connection.status() == Records.ConnectionStatus.GENERATING) {
                Records.StructureConnection resetConnection = new Records.StructureConnection(
                    connection.from(), connection.to(), Records.ConnectionStatus.PLANNED, connection.manual()
                );
                updatedConnections.set(i, resetConnection);
                StructureConnector.cachedStructureConnections.add(resetConnection);
            } else {
                // PLANNED ç›´æ¥åŠ å…¥é˜Ÿåˆ—
                StructureConnector.cachedStructureConnections.add(connection);
            }
        }
        // COMPLETED å’Œ FAILED ä¸å¤„ç†
    }
}
```

**æ¢å¤ç­–ç•¥:**
| åŸçŠ¶æ€ | æ“ä½œ | æ–°çŠ¶æ€ |
|--------|------|--------|
| `PLANNED` | ç›´æ¥å…¥é˜Ÿ | `PLANNED` |
| `GENERATING` | é‡ç½®åå…¥é˜Ÿ | `PLANNED` |
| `COMPLETED` | å¿½ç•¥ | `COMPLETED` |
| `FAILED` | å¿½ç•¥ | `FAILED` |

---

## é“è·¯ç”Ÿæˆæµç¨‹

### é˜¶æ®µ 1: ä»»åŠ¡è°ƒåº¦

#### 1.1 å¹¶å‘æ£€æŸ¥
```java
// ModEventHandler.java:111-148
private static void tryGenerateNewRoads(ServerLevel level, Boolean async, int steps) {
    // 1. æ£€æŸ¥åˆå§‹åŒ–å»¶è¿Ÿ
    Integer delayTicks = worldInitDelay.get(worldKey);
    if (delayTicks != null && delayTicks > 0) {
        worldInitDelay.put(worldKey, delayTicks - 1);
        return;  // è¿˜åœ¨å»¶è¿ŸæœŸå†…
    }
    
    // 2. æ¸…ç†å·²å®Œæˆçš„ä»»åŠ¡
    runningTasks.entrySet().removeIf(entry -> entry.getValue().isDone());
    
    // 3. å¹¶å‘ä¸Šé™æ£€æŸ¥
    int currentRunning = runningTasks.size();
    if (currentRunning >= config.maxConcurrentRoadGeneration()) {
        return;  // è¾¾åˆ°å¹¶å‘ä¸Šé™
    }
    
    // 4. ä»é˜Ÿåˆ—å–å‡ºä»»åŠ¡
    // ... (è§é˜Ÿåˆ—ç®¡ç†éƒ¨åˆ†)
}
```

**å¹¶å‘æ§åˆ¶å‚æ•°:**
- `maxConcurrentRoadGeneration` - æœ€å¤§å¹¶å‘é“è·¯ç”Ÿæˆæ•° (é…ç½®é¡¹)
- `THREAD_COUNT = 7` - çº¿ç¨‹æ± å¤§å°

#### 1.2 å¼‚æ­¥ä»»åŠ¡æäº¤
```java
// ModEventHandler.java:172-196
if (async) {
    String taskId = level.dimension().location().toString() + "_" + System.nanoTime();
    Future<?> future = executor.submit(() -> {
        try {
            new Road(level, structureConnection, roadConfig).generateRoad(steps);
            LOGGER.info("âœ… Road generation completed");
        } catch (Exception e) {
            LOGGER.error("âŒ Error generating road", e);
            markConnectionAsFailed(level, structureConnection);
        } finally {
            runningTasks.remove(taskId);
        }
    });
    runningTasks.put(taskId, future);
}
```

### é˜¶æ®µ 2: é“è·¯ç”Ÿæˆ

#### 2.1 ç”Ÿæˆä¸»æµç¨‹
```java
// Road.java:30-70
public void generateRoad(int maxSteps) {
    // 1. æ›´æ–°çŠ¶æ€ä¸º GENERATING
    updateConnectionStatus(Records.ConnectionStatus.GENERATING);
    
    // 2. éšæœºé€‰æ‹©é“è·¯å‚æ•°
    int width = getRandomWidth(random, context.getWidths());
    int type = allowedRoadTypes(random, cfg);  // 0=äººå·¥, 1=è‡ªç„¶
    List<BlockState> material = getRandomMaterials(random, materialsList);
    
    // 3. è·å–é˜ˆå€¼å‚æ•°
    int maxHeightDiff = structureConnection.manual() 
        ? cfg.manualMaxHeightDifference() 
        : cfg.maxHeightDifference();
    int maxStability = structureConnection.manual() 
        ? cfg.manualMaxTerrainStability() 
        : cfg.maxTerrainStability();
    
    // 4. è®¡ç®— A* è·¯å¾„
    List<Records.RoadSegmentPlacement> roadSegmentPlacementList = 
        RoadPathCalculator.calculateAStarRoadPath(
            start, end, width, serverWorld, maxSteps, maxHeightDiff, maxStability
        );
    
    // 5. ä¿å­˜é“è·¯æ•°æ®
    if (!roadSegmentPlacementList.isEmpty()) {
        mutableList.add(new Records.RoadData(width, type, material, roadSegmentPlacementList));
        dataProvider.setRoadDataList(serverWorld, mutableList);
        updateConnectionStatus(Records.ConnectionStatus.COMPLETED);
    } else {
        updateConnectionStatus(Records.ConnectionStatus.FAILED);
    }
}
```

#### 2.2 æ‰‹åŠ¨ vs è‡ªåŠ¨è¿æ¥
| å‚æ•° | è‡ªåŠ¨è¿æ¥ | æ‰‹åŠ¨è¿æ¥ |
|------|----------|----------|
| æœ€å¤§é«˜åº¦å·® | `maxHeightDifference` | `manualMaxHeightDifference` |
| åœ°å½¢ç¨³å®šæ€§ | `maxTerrainStability` | `manualMaxTerrainStability` |
| ç‰¹ç‚¹ | ä¿å®ˆç­–ç•¥ | æ¿€è¿›ç­–ç•¥ (æ›´å®½å®¹) |

---

## å¹¶å‘æ§åˆ¶

### 1. çº¿ç¨‹æ± é…ç½®
```java
// ModEventHandler.java:35-37
private static final int THREAD_COUNT = 7;
private static ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
```

### 2. ä»»åŠ¡è¿½è¸ª
```java
// ModEventHandler.java:38
private static final ConcurrentHashMap<String, Future<?>> runningTasks = new ConcurrentHashMap<>();
```

**ä»»åŠ¡ ID æ ¼å¼:**
```
minecraft:overworld_1234567890123456789
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   ä¸–ç•Œç»´åº¦        çº³ç§’æ—¶é—´æˆ³
```

### 3. å¹¶å‘é™åˆ¶æµç¨‹
```mermaid
graph TD
    A[Tick äº‹ä»¶] --> B{é˜Ÿåˆ—éç©º?}
    B -->|å¦| Z[ç»“æŸ]
    B -->|æ˜¯| C[æ¸…ç†å·²å®Œæˆä»»åŠ¡]
    C --> D{å½“å‰è¿è¡Œæ•° < ä¸Šé™?}
    D -->|å¦| Z
    D -->|æ˜¯| E[Peek é˜Ÿåˆ—å¤´éƒ¨]
    E --> F{æ³¨å†Œè¡¨å°±ç»ª?}
    F -->|å¦| Z
    F -->|æ˜¯| G[Poll å‡ºé˜Ÿ]
    G --> H[æäº¤å¼‚æ­¥ä»»åŠ¡]
    H --> I[è®°å½•åˆ° runningTasks]
```

### 4. ç”Ÿå‘½å‘¨æœŸç®¡ç†
```java
// ModEventHandler.java:73-79
LifecycleEvent.SERVER_STOPPING.register(server -> {
    RoadPathCalculator.heightCache.clear();
    runningTasks.values().forEach(future -> future.cancel(true));
    runningTasks.clear();
    executor.shutdownNow();
});
```

---

## çŠ¶æ€ç®¡ç†

### 1. çŠ¶æ€è½¬æ¢å›¾
```mermaid
stateDiagram-v2
    [*] --> PLANNED: åˆ›å»ºè¿æ¥
    PLANNED --> GENERATING: å¼€å§‹ç”Ÿæˆ
    GENERATING --> COMPLETED: ç”ŸæˆæˆåŠŸ
    GENERATING --> FAILED: ç”Ÿæˆå¤±è´¥/å¼‚å¸¸
    GENERATING --> PLANNED: ä¸–ç•Œé‡è½½ (æ„å¤–ä¸­æ–­)
    COMPLETED --> [*]
    FAILED --> [*]
```

### 2. çŠ¶æ€æ›´æ–°å®ç°
```java
// Road.java:72-87
private void updateConnectionStatus(Records.ConnectionStatus newStatus) {
    List<Records.StructureConnection> connections = dataProvider.getStructureConnections(serverWorld);
    List<Records.StructureConnection> mutableConnections = new ArrayList<>(connections);
    
    for (int i = 0; i < mutableConnections.size(); i++) {
        Records.StructureConnection conn = mutableConnections.get(i);
        // åŒå‘åŒ¹é… (from->to æˆ– to->from)
        if ((conn.from().equals(structureConnection.from()) && conn.to().equals(structureConnection.to())) ||
            (conn.from().equals(structureConnection.to()) && conn.to().equals(structureConnection.from()))) {
            mutableConnections.set(i, new Records.StructureConnection(
                conn.from(), conn.to(), newStatus, conn.manual()
            ));
            dataProvider.setStructureConnections(serverWorld, mutableConnections);
            break;
        }
    }
}
```

### 3. å¤±è´¥å¤„ç†
```java
// ModEventHandler.java:265-281
private static void markConnectionAsFailed(ServerLevel level, Records.StructureConnection structureConnection) {
    // 1. è·å–æ‰€æœ‰è¿æ¥
    List<Records.StructureConnection> connections = dataProvider.getStructureConnections(level);
    List<Records.StructureConnection> mutableConnections = new ArrayList<>(connections);
    
    // 2. æŸ¥æ‰¾å¹¶æ›´æ–°çŠ¶æ€
    for (int i = 0; i < mutableConnections.size(); i++) {
        Records.StructureConnection conn = mutableConnections.get(i);
        if (matchesConnection(conn, structureConnection)) {
            mutableConnections.set(i, new Records.StructureConnection(
                conn.from(), conn.to(), Records.ConnectionStatus.FAILED, conn.manual()
            ));
            dataProvider.setStructureConnections(level, mutableConnections);
            break;
        }
    }
}
```

---

## å…³é”®æ—¶åºå›¾

### å®Œæ•´æµç¨‹æ—¶åº
```mermaid
sequenceDiagram
    participant W as ä¸–ç•ŒåŠ è½½
    participant T as Tick äº‹ä»¶
    participant SC as StructureConnector
    participant SL as StructureLocator
    participant Q as é˜Ÿåˆ—
    participant ME as ModEventHandler
    participant R as Road
    participant DP as DataProvider

    W->>ME: onWorldLoad
    ME->>ME: è®¾ç½®å»¶è¿Ÿ (100 ticks)
    ME->>ME: restoreUnfinishedRoads
    ME->>Q: æ¢å¤ PLANNED/GENERATING
    ME->>SC: cacheNewConnection (åˆå§‹åŒ–)
    SC->>SL: locateConfiguredStructure
    SL->>DP: ä¿å­˜ç»“æ„ä½ç½®
    SC->>SC: findClosestStructure
    SC->>Q: add(connection)
    SC->>DP: ä¿å­˜è¿æ¥

    loop æ¯ä¸ª Tick
        T->>ME: tryGenerateNewRoads
        ME->>ME: æ£€æŸ¥å»¶è¿Ÿ
        alt å»¶è¿Ÿæœªç»“æŸ
            ME-->>T: return
        end
        ME->>ME: æ¸…ç†å·²å®Œæˆä»»åŠ¡
        ME->>ME: æ£€æŸ¥å¹¶å‘ä¸Šé™
        alt è¾¾åˆ°ä¸Šé™
            ME-->>T: return
        end
        ME->>Q: peek()
        Q-->>ME: connection
        ME->>ME: getRoadFeatureConfig
        alt æ³¨å†Œè¡¨æœªå°±ç»ª
            ME-->>T: return (ç­‰å¾…ä¸‹ä¸€ä¸ª tick)
        end
        ME->>Q: poll()
        Q-->>ME: connection
        ME->>R: generateRoad (å¼‚æ­¥)
        R->>DP: æ›´æ–°çŠ¶æ€ GENERATING
        R->>R: calculateAStarRoadPath
        R->>DP: ä¿å­˜é“è·¯æ•°æ®
        R->>DP: æ›´æ–°çŠ¶æ€ COMPLETED/FAILED
    end
```

---

## é…ç½®å‚æ•°æ±‡æ€»

### ç»“æ„æœå¯»ç›¸å…³
| å‚æ•° | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `structuresToLocate` | `List<String>` | ç›®æ ‡ç»“æ„åˆ—è¡¨ (æ”¯æŒæ ‡ç­¾ `#` å’Œå•ä¸ªç»“æ„) |
| `structureSearchRadius` | `int` | æœç´¢åŠå¾„ (åŒºå—) |
| `initialLocatingCount` | `int` | ä¸–ç•ŒåŠ è½½æ—¶åˆå§‹æœå¯»æ•°é‡ |

### é“è·¯ç”Ÿæˆç›¸å…³
| å‚æ•° | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `maxConcurrentRoadGeneration` | `int` | æœ€å¤§å¹¶å‘ç”Ÿæˆæ•° |
| `maxHeightDifference` | `int` | è‡ªåŠ¨è¿æ¥æœ€å¤§é«˜åº¦å·® |
| `maxTerrainStability` | `int` | è‡ªåŠ¨è¿æ¥åœ°å½¢ç¨³å®šæ€§é˜ˆå€¼ |
| `manualMaxHeightDifference` | `int` | æ‰‹åŠ¨è¿æ¥æœ€å¤§é«˜åº¦å·® (æ›´å®½å®¹) |
| `manualMaxTerrainStability` | `int` | æ‰‹åŠ¨è¿æ¥åœ°å½¢ç¨³å®šæ€§é˜ˆå€¼ (æ›´å®½å®¹) |

### é“è·¯å¤–è§‚ç›¸å…³
| å‚æ•° | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `allowArtificial` | `boolean` | å…è®¸äººå·¥é“è·¯æè´¨ |
| `allowNatural` | `boolean` | å…è®¸è‡ªç„¶é“è·¯æè´¨ |
| `averagingRadius` | `int` | é«˜åº¦å¹³å‡åŒ–åŠå¾„ |

---

## æ½œåœ¨é—®é¢˜ä¸ä¼˜åŒ–å»ºè®®

### 1. çº¿ç¨‹å®‰å…¨é—®é¢˜
**é—®é¢˜:** `cachedStructureConnections` ä½¿ç”¨éçº¿ç¨‹å®‰å…¨çš„ `ArrayDeque`

**é£é™©:**
- è™½ç„¶å½“å‰è®¾è®¡ä¾èµ–å•çº¿ç¨‹ tick è®¿é—®ï¼Œä½†å¤šçº¿ç¨‹ä»»åŠ¡å®Œæˆå›è°ƒå¯èƒ½å¯¼è‡´ç«æ€æ¡ä»¶

**å»ºè®®:**
```java
// æ›¿æ¢ä¸ºçº¿ç¨‹å®‰å…¨é˜Ÿåˆ—
public static Queue<Records.StructureConnection> cachedStructureConnections = 
    new ConcurrentLinkedQueue<>();
```

### 2. é˜Ÿåˆ—æŒä¹…åŒ–ç¼ºå¤±
**é—®é¢˜:** é˜Ÿåˆ—ä»…åœ¨å†…å­˜ä¸­ï¼ŒæœåŠ¡å™¨å´©æºƒä¼šä¸¢å¤±é˜Ÿåˆ—å†…å®¹

**å»ºè®®:**
- ä¾èµ– `restoreUnfinishedRoads` ä»æŒä¹…åŒ–æ•°æ®æ¢å¤
- å½“å‰è®¾è®¡å·²é€šè¿‡çŠ¶æ€æ¢å¤æœºåˆ¶ç¼“è§£æ­¤é—®é¢˜

### 3. æœç´¢ä¸­å¿ƒç‚¹ç­–ç•¥
**ä¼˜ç‚¹:**
- å¤šæ–¹å‘é‡‡æ ·æé«˜è¦†ç›–ç‡
- ç©å®¶ä½ç½®ä¼˜å…ˆç¡®ä¿ç›¸å…³æ€§

**å¯ä¼˜åŒ–:**
- æ·»åŠ å·²æœç´¢åŒºåŸŸè®°å½•ï¼Œé¿å…é‡å¤æœç´¢
- åŠ¨æ€è°ƒæ•´é‡‡æ ·åŠå¾„å€æ•°

### 4. å¹¶å‘æ§åˆ¶
**ä¼˜ç‚¹:**
- çº¿ç¨‹æ± å¤ç”¨å‡å°‘å¼€é”€
- ä»»åŠ¡è¿½è¸ªæ”¯æŒæ¸…ç†å’Œå–æ¶ˆ

**å¯ä¼˜åŒ–:**
- æ ¹æ®æœåŠ¡å™¨æ€§èƒ½åŠ¨æ€è°ƒæ•´çº¿ç¨‹æ± å¤§å°
- æ·»åŠ ä»»åŠ¡ä¼˜å…ˆçº§é˜Ÿåˆ— (æ‰‹åŠ¨è¿æ¥ä¼˜å…ˆ)

---

## æ€»ç»“

### æ ¸å¿ƒè®¾è®¡äº®ç‚¹
1. âœ… **Peek-Poll æ¨¡å¼** - ç¡®ä¿èµ„æºå°±ç»ªåå†å‡ºé˜Ÿ
2. âœ… **çŠ¶æ€æ¢å¤æœºåˆ¶** - ä¸–ç•Œé‡è½½åè‡ªåŠ¨æ¢å¤æœªå®Œæˆä»»åŠ¡
3. âœ… **åˆå§‹åŒ–å»¶è¿Ÿ** - é¿å…æ³¨å†Œè¡¨æœªå°±ç»ªå¯¼è‡´çš„é”™è¯¯
4. âœ… **åŒå‘è¿æ¥æ£€æŸ¥** - é˜²æ­¢é‡å¤åˆ›å»ºç›¸åŒè¿æ¥
5. âœ… **æ‰‹åŠ¨/è‡ªåŠ¨é˜ˆå€¼åˆ†ç¦»** - çµæ´»çš„ç”Ÿæˆç­–ç•¥

### æ•°æ®æµå‘
```
ç»“æ„æœå¯» â†’ è¿æ¥åˆ›å»º â†’ é˜Ÿåˆ—ç¼“å­˜ â†’ ä»»åŠ¡è°ƒåº¦ â†’ é“è·¯ç”Ÿæˆ â†’ çŠ¶æ€æ›´æ–° â†’ æ•°æ®æŒä¹…åŒ–
    â†‘                                                              â†“
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ä¸–ç•Œé‡è½½æ¢å¤ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å…³é”®æŒ‡æ ‡
- **é˜Ÿåˆ—ç±»å‹**: `ArrayDeque` (FIFO)
- **å¹¶å‘æ¨¡å‹**: å›ºå®šçº¿ç¨‹æ±  (7 çº¿ç¨‹)
- **çŠ¶æ€æ•°**: 4 ç§ (PLANNED, GENERATING, COMPLETED, FAILED)
- **åˆå§‹åŒ–å»¶è¿Ÿ**: 100 ticks (5 ç§’)
- **æœç´¢é‡‡æ ·**: 1 + 16 ä¸ªä¸­å¿ƒç‚¹ (å‡ºç”Ÿç‚¹ + 8æ–¹å‘ Ã— 2å€æ•°)
