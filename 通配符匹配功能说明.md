# 通配符匹配功能说明

## 🎯 功能概述

现在支持使用 **通配符 `*`** 来批量匹配结构，无需逐个输入每个小类结构！

## 📝 使用方法

### 基本语法

在配置文件中，可以使用 `*` 作为通配符来匹配多个结构：

```
modid:structure_*
```

这会匹配所有以 `modid:structure_` 开头的结构。

### 示例场景

#### 场景 1: 匹配某个模组的所有结构
```
# 匹配 youkaishomecoming 模组的所有结构
youkaishomecoming:*
```

#### 场景 2: 匹配特定前缀的结构
```
# 匹配所有以 village_ 开头的结构
minecraft:village_*

# 匹配所有以 ancient_ 开头的结构
minecraft:ancient_*

# 匹配所有 houses 目录下的结构
mvs:houses/*
```

#### 场景 3: 匹配特定类型的建筑
```
# 匹配所有神社类建筑
youkaishomecoming:shrine_*

# 匹配所有巢穴类建筑
youkaishomecoming:nest_*
```

#### 场景 4: 混合使用
```
# 可以同时使用标签、精确ID和通配符
#minecraft:village
youkaishomecoming:*
dungeons_arise:*
```

## 🔧 配置示例

### Fabric/NeoForge 配置文件

#### 单行配置（旧格式）
```json
{
  "structureToLocate": "#minecraft:village, youkaishomecoming:*, dungeons_arise:*"
}
```

#### 多行配置（新格式）
```json
{
  "structuresToLocate": [
    "#minecraft:village",
    "youkaishomecoming:*",
    "dungeons_arise:*",
    "minecraft:ancient_*"
  ]
}
```

## 📊 匹配规则

### 1. 前缀匹配
通配符 `*` 会被替换为空字符串，然后进行**前缀匹配**：

| 输入 | 匹配逻辑 | 示例匹配 |
|------|----------|----------|
| `modid:*` | 以 `modid:` 开头 | `modid:structure1`, `modid:structure2` |
| `modid:shrine_*` | 以 `modid:shrine_` 开头 | `modid:shrine_red`, `modid:shrine_blue` |
| `mvs:houses/*` | 以 `mvs:houses/` 开头 | `mvs:houses/azelea_house`, `mvs:houses/oak_house` |
| `*:village` | 以 `:village` 开头 | ❌ 不推荐（会匹配到 `:village` 开头的） |

### 2. 匹配优先级
1. **标签匹配** (`#modid:tag`) - 最高优先级
2. **通配符匹配** (`modid:*`) - 中等优先级
3. **精确匹配** (`modid:structure`) - 最低优先级

### 3. 去重机制
如果多个规则匹配到同一个结构，只会添加一次（自动去重）。

## 🔍 日志输出

### 成功匹配
```
[INFO] RoadWeaver: 通配符 'youkaishomecoming:*' 匹配到 5 个结构
```

### 未匹配到任何结构
```
[WARN] RoadWeaver: 通配符 'nonexistent:*' 未匹配到任何结构
```

### 详细匹配信息
启用 DEBUG 日志级别可以看到具体匹配的结构：
```
[DEBUG] RoadWeaver: 定位到 5 个新结构: [BlockPos{...}, ...]
```

## ⚠️ 注意事项

### 1. 性能考虑
- 通配符匹配需要遍历整个结构注册表
- 如果匹配到大量结构（如 `*:*`），可能影响性能
- 建议使用具体的前缀，避免过于宽泛的匹配

### 2. 推荐用法
✅ **推荐**:
```
youkaishomecoming:shrine_*    # 具体前缀
dungeons_arise:*               # 模组级别
```

❌ **不推荐**:
```
*:*                            # 匹配所有结构（性能差）
*                              # 无效（会被当作精确匹配）
```

### 3. 兼容性
- ✅ 支持与标签混用
- ✅ 支持与精确 ID 混用
- ✅ 支持多行配置
- ✅ 向后兼容旧配置

## 📖 实际案例

### 案例 1: MVS (More Vanilla Structures) 模组
MVS 模组使用路径格式组织结构：
- `mvs:houses/azelea_house`
- `mvs:houses/oak_house`
- `mvs:shops/blacksmith`
- `mvs:shops/library`

**配置**:
```json
{
  "structuresToLocate": [
    "mvs:houses/*",    // 所有房屋
    "mvs:shops/*",     // 所有商店
    "mvs:*"            // 或者直接匹配所有 MVS 结构
  ]
}
```

**结果**: 自动匹配所有 MVS 模组的结构，无需逐个输入！

### 案例 2: 妖怪之家模组
假设 `youkaishomecoming` 模组有以下结构：
- `youkaishomecoming:shrine_red`
- `youkaishomecoming:shrine_blue`
- `youkaishomecoming:nest_small`
- `youkaishomecoming:nest_large`

**配置**:
```json
{
  "structuresToLocate": [
    "youkaishomecoming:shrine_*",
    "youkaishomecoming:nest_*"
  ]
}
```

**结果**: 匹配到所有 4 个结构

### 案例 3: 多个模组混合
```json
{
  "structuresToLocate": [
    "#minecraft:village",           // 原版村庄标签
    "youkaishomecoming:*",          // 妖怪之家所有结构
    "dungeons_arise:*",             // 地牢崛起所有结构
    "minecraft:ancient_city"        // 原版远古城市（精确）
  ]
}
```

### 案例 4: 细粒度控制
```json
{
  "structuresToLocate": [
    "modid:castle_*",               // 只要城堡类
    "modid:tower_*",                // 只要塔类
    "modid:dungeon_underground_*",  // 只要地下地牢
    "mvs:houses/*",                 // MVS 模组的所有房屋
    "mvs:shops/*"                   // MVS 模组的所有商店
  ]
}
```

## 🔧 高级用法

### 1. 调试匹配结果
在配置中添加一个测试通配符，查看日志输出：
```json
{
  "structuresToLocate": [
    "youkaishomecoming:*"
  ]
}
```

启动游戏后查看日志：
```
[INFO] RoadWeaver: 通配符 'youkaishomecoming:*' 匹配到 12 个结构
```

### 2. 排除特定结构
目前不支持排除语法，但可以通过精确列举来实现：
```json
{
  "structuresToLocate": [
    "modid:structure_a",
    "modid:structure_b",
    "modid:structure_c"
    // 不包含 modid:structure_d
  ]
}
```

### 3. 组合使用
```json
{
  "structuresToLocate": [
    "#minecraft:village",           // 标签：所有村庄
    "minecraft:pillager_outpost",   // 精确：掠夺者前哨站
    "youkaishomecoming:*",          // 通配符：所有妖怪建筑
    "dungeons_arise:shiraz_*"       // 通配符：特定系列
  ]
}
```

## 🎯 最佳实践

### 1. 从宽到窄
先用通配符快速测试：
```
youkaishomecoming:*
```

如果匹配过多，再缩小范围：
```
youkaishomecoming:shrine_*
```

### 2. 查看模组文档
在模组的 Wiki 或源码中查找结构 ID 的命名规律，然后使用通配符。

### 3. 使用日志验证
启动游戏后检查日志，确认匹配到的结构数量是否符合预期。

### 4. 性能优化
如果服务器性能有限，避免使用过于宽泛的通配符（如 `modid:*`），改用更具体的前缀。

## 📊 性能对比

| 配置方式 | 性能 | 灵活性 | 推荐场景 |
|----------|------|--------|----------|
| 标签 `#tag` | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 原版/大型模组 |
| 精确 ID | ⭐⭐⭐⭐⭐ | ⭐⭐ | 少量特定结构 |
| 通配符 `*` | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 模组结构批量添加 |

## 🚀 总结

通配符功能让你可以：
- ✅ **快速添加**整个模组的所有结构
- ✅ **批量匹配**同类型的建筑
- ✅ **简化配置**，无需逐个输入
- ✅ **灵活组合**标签、精确ID和通配符

**示例配置**:
```json
{
  "structuresToLocate": [
    "#minecraft:village",
    "youkaishomecoming:*",
    "dungeons_arise:*"
  ]
}
```

现在你可以轻松管理大量模组结构，无需手动输入每一个！🎉
